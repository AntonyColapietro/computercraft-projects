W="forward"
S="back"
D="right"
A="left"
E="up"
Q="down"
path={W}   --counting first step
ypath={}
xpathD={D,D}
xpathA={A,A}
zpathO={Q,Q,Q,S,W}  --path used for odd Z transitions or even Z transitions
zpathE={Q,Q,S,W}
zpathL={Q,S,W}  --corner case in odd Z transitions
FIRST=1


  function updatePath(list)
   for i=1,#list do
      writeStep(path,list[i],#path+1)
    end
  end


 function writePlan(x,y,index)
   if index%2==1 then
     for i=1,x do
       updatePath(ypath)
       corner(i)
     end
   else
      for i=1,x do
        updatePath(ypath)
        corner(i+1)
      end
   end
  updatePath(ypath)
end


 function corner(index)
    if index%2==1 then
        updatePath(xpathD)
    else
        updatePath(xpathA)
   end
end

  function writePath(x,y,z)
   --initiliaze parts of the path
   local x1=x-1        --local variables for transitions
   local y1=y-1
   local z1=z-1
   for j=2,y1 do     --ypath (excluded first step, change of column right/left (x) and change of level (z))
    writeStep(ypath,W,FIRST)
   end
   writeCube(x1,y1,z1)

  end

 function writeCube(x,y,z)
  local tz=0 
  if z%2 == 1 then 
     tz=(z-1)/2 
    for i=1,tz do
      writePlan(x,y,i)    --even or odd i parameter will change output of writeplan
     	if(i<tz) then
      	  updatePath(zpathO)
        else
          if(z==3) then 
           updatePath(zpathE) --particular corner case 
          else
          updatePath(zpathL)
          end
          writePlan(x,y,i+1)
        end 
    end
  else
     tz=z/2
     for i=1,tz do
      writePlan(x,y,i)
    	 if(i<tz-1) then
     	  	updatePath(zpathO)
         else
                updatePath(zpathE)
                writePlan(x,y,i+1)
         end
     end
  end

 end   
      


   
  



  function writeStep(whichpath,direction,position)
             table.insert(whichpath,position,direction)
   end



  function getStep(step)
        return path[step]
  end



  function getPath()
        return path
   end
