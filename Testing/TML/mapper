W="forward"
S="back"
D="right"
A="left"
E="up"
Q="down"
path={W}   --counting first step
ypath={}
xpathD={D,D}
xpathA={A,A}
zpathO={Q,Q,Q,R,R,W}  --path used for odd Z transitions or even Z transitions
zpathE={Q,Q,R,R,W}
FIRST=1


  function updatePath(list)
   for i=1,#list do
      writeStep(path,list[i],#path)
    end
  end

 function writePlan(x,y,index)
   if index%2==1 then
     for i=1,x do
       updatePath(ypath)
       corner(i)
     end
   
   else
      for i=1,x do
        updatePath(ypath)
        corner(i+1)
      end
     updatePath(ypath)
   end
end


 function corner(index)
    if index%2==1 then
        updatePath(xpathD)
    else
        updatePath(xpathA)
   end
end

  function writePath(x,y,z)
   --initiliaze parts of the path
   local x1=x-1        --local variables for transitions
   local y1=y-1
   local z1=z-1
   writecube(x1,y1,z1)
   
    for i=2,y1 do     --ypath (excluded change of column right/left (x) or change of level (z))
      writeStep(ypath,i,W)
    end

  end

 function writecube(x,y,z)
  local tz=0 
  if z%2 == 1 then 
     tz=(z-1)/2 
    for i=1,tz do
      writePlan(x,y,i)    --even or odd i parameter will change output of writeplan
     	if(i<tz) then
      	  addLevel(zpathO)
        end 
    end
  else
     tz=z/2
     for i=1,tz do
      writePlan(x,y,i)
    	 if(i<tz) then
     	  	updatePath(zpathO)
         else
                updatePath(zpathE)
         end
     end
  end

 end   
      


   
  



  function writeStep(whichpath,direction,position)
             table.insert(whichpath,position,direction)
   end



  function getStep(step)
        return path[step]
  end



  function getPath()
        return path
   end
